# Claude Task: Standardize Proof Package Export (v1.0) â€” Folder/ZIP + Metadata

## ðŸŽ¯ Goal
Extend the existing `proof export` capability to produce a **standardized proof package** with a fixed structure, either as a folder or a ZIP archive, without new cryptography.  
This enables a licensable **`.cap-proof.zip`** distribution and consistent auditor handoff.

---

## ðŸ§± Package Structure (v1.0)

**Folder name (default):** `build/cap-proof/`  
**Optional archive:** `build/cap-proof.zip` (same contents)

```
cap-proof/
â”œâ”€ manifest.json            # Generated by agent (already exists)
â”œâ”€ proof.dat                # ZK mock today; future: proof.zkp
â”œâ”€ timestamp.tsr            # Timestamp (mock today)
â”œâ”€ registry.json            # Local proof registry entry/entries
â”œâ”€ verification.report.json # Result from 'cap manifest verify' (optional but recommended)
â”œâ”€ README.txt               # Human-readable instructions
â””â”€ _meta.json               # Machine-readable metadata (hashes, versions)
```

> Note: If `verification.report.json` is not provided, create a minimal report with status `"unknown"`.

---

## ðŸ”§ CLI Extensions

### Command
```bash
cap proof export \
  --manifest build/manifest.json \
  --proof build/zk_proof.dat \
  [--timestamp build/timestamp.tsr] \
  [--registry build/registry.json] \
  [--report build/verification.report.json] \
  [--out build/cap-proof] \
  [--zip] \
  [--force]
```

### Behavior
1. Create output dir (default `build/cap-proof/`), optionally remove if `--force`.
2. Copy/normalize files into package.
3. Generate `README.txt` and `_meta.json` (hashes, versions, created_at).
4. If `--zip` â†’ create `build/cap-proof.zip`.

---

## ðŸ§© Implementation

### 1) New File: `agent/src/cli/proof_export.rs`
```rust
use anyhow::{Result, bail, Context};
use serde::{Serialize, Deserialize};
use sha3::{Digest, Sha3_256};
use std::{fs, path::{Path, PathBuf}};
use chrono::Utc;

#[derive(Serialize, Deserialize)]
struct PackageMeta {
    version: String,                // "cap-proof.v1.0"
    created_at: String,             // RFC3339
    files: PackageFiles,
    hashes: PackageHashes,
}

#[derive(Serialize, Deserialize)]
struct PackageFiles {
    manifest: String,
    proof: String,
    timestamp: Option<String>,
    registry: Option<String>,
    report: Option<String>,
    readme: String,
}

#[derive(Serialize, Deserialize, Default)]
struct PackageHashes {
    manifest_sha3: String,
    proof_sha3: String,
    timestamp_sha3: Option<String>,
    registry_sha3: Option<String>,
    report_sha3: Option<String>,
}

fn sha3_hex(path: &Path) -> Result<String> {
    let bytes = fs::read(path)?;
    Ok(format!("0x{:x}", Sha3_256::digest(bytes)))
}

pub fn run(manifest: &str, proof: &str, timestamp: Option<&str>, registry: Option<&str>, report: Option<&str>, out: Option<&str>, zip: bool, force: bool) -> Result<()> {
    // 1. prepare out dir
    let out_dir = PathBuf::from(out.unwrap_or("build/cap-proof"));
    if out_dir.exists() {
        if force {
            fs::remove_dir_all(&out_dir).context("failed to remove existing out dir")?;
        } else {
            bail!("output directory already exists; use --force to overwrite");
        }
    }
    fs::create_dir_all(&out_dir)?;

    // 2. copy files
    let manifest_dst = out_dir.join("manifest.json");
    let proof_dst = out_dir.join("proof.dat"); // future: proof.zkp
    fs::copy(manifest, &manifest_dst)?;
    fs::copy(proof, &proof_dst)?;

    let ts_dst = if let Some(ts) = timestamp {
        let p = out_dir.join("timestamp.tsr");
        fs::copy(ts, &p)?;
        Some(p)
    } else { None };

    let reg_dst = if let Some(reg) = registry {
        let p = out_dir.join("registry.json");
        fs::copy(reg, &p)?;
        Some(p)
    } else { None };

    let rep_dst = if let Some(rep) = report {
        let p = out_dir.join("verification.report.json");
        fs::copy(rep, &p)?;
        Some(p)
    } else {
        // create minimal report
        let p = out_dir.join("verification.report.json");
        fs::write(&p, r#"{ "status": "unknown" }"#)?;
        Some(p)
    };

    // 3. README.txt
    let readme_dst = out_dir.join("README.txt");
    let readme = format!(r#"CAP Proof Package (v1.0)

Files:
- manifest.json
- proof.dat
- timestamp.tsr (optional)
- registry.json (optional)
- verification.report.json
- _meta.json (hashes & versions)

Verify (offline):
  cap manifest verify \
    --manifest manifest.json \
    --proof proof.dat \
    --registry registry.json \
    --timestamp timestamp.tsr \
    --out verification.report.json
"#);
    fs::write(&readme_dst, readme)?;

    // 4. _meta.json (hashes)
    let hashes = PackageHashes {
        manifest_sha3: sha3_hex(&manifest_dst)?,
        proof_sha3: sha3_hex(&proof_dst)?,
        timestamp_sha3: ts_dst.as_ref().map(|p| sha3_hex(p).ok()).flatten(),
        registry_sha3: reg_dst.as_ref().map(|p| sha3_hex(p).ok()).flatten(),
        report_sha3: rep_dst.as_ref().map(|p| sha3_hex(p).ok()).flatten(),
    };

    let meta = PackageMeta {
        version: "cap-proof.v1.0".into(),
        created_at: Utc::now().to_rfc3339(),
        files: PackageFiles {
            manifest: "manifest.json".into(),
            proof: "proof.dat".into(),
            timestamp: ts_dst.as_ref().map(|_| "timestamp.tsr".into()),
            registry: reg_dst.as_ref().map(|_| "registry.json".into()),
            report: Some("verification.report.json".into()),
            readme: "README.txt".into(),
        },
        hashes,
    };
    fs::write(out_dir.join("_meta.json"), serde_json::to_string_pretty(&meta)?)?;

    // 5. optional zip
    if zip {
        // naive zip via zip crate (add dependency: zip = "0.6")
        // Pseudocode placeholder: collect files, write archive
        // Left for Claude to implement with the chosen zip crate.
        println!("(info) ZIP requested â€” create build/cap-proof.zip using 'zip' crate");
    }

    println!("âœ… Proof package exported to {}", out_dir.display());
    Ok(())
}
```

---

### 2) Register Command in CLI
**File:** `agent/src/main.rs`
```rust
.subcommand(
    Command::new("proof")
        .about("Proof operations")
        .subcommand(
            Command::new("export")
                .about("Export a standardized CAP proof package")
                .arg(arg!(--manifest <FILE> "Manifest JSON file"))
                .arg(arg!(--proof <FILE> "Proof DAT file"))
                .arg(arg!(--timestamp [FILE] "Timestamp TSR file"))
                .arg(arg!(--registry [FILE] "Registry JSON file"))
                .arg(arg!(--report [FILE] "Verification report JSON file"))
                .arg(arg!(--out [DIR] "Output directory (default: build/cap-proof)"))
                .arg(arg!(--zip "Create cap-proof.zip next to the directory"))
                .arg(arg!(--force "Overwrite output directory if it exists"))
        )
)
```

---

### 3) Align Manifest References (consistency only)
Ensure the generated `manifest.json` contains file-hash references that **match the exported package** (no new fields required if already present):
- `manifest_hash = sha3(manifest.json)`
- `proof_hash    = sha3(proof.dat)`
- Reference these values in registry/timestamp flows as already implemented.

If you choose to add a non-breaking, optional block for clarity:
```json
"package": {
  "format": "cap-proof.v1.0",
  "files": ["manifest.json","proof.dat","timestamp.tsr","registry.json","verification.report.json"]
}
```
> This should go under `extensions` to avoid breaking `manifest.v1.0` schema.

---

## ðŸ§ª Tests

**File:** `agent/tests/test_proof_export.rs`
```rust
#[test]
fn test_export_package_folder() {
    // Arrange paths to test fixtures
    let out = "tests/out/cap-proof";
    let _ = std::fs::remove_dir_all(out);
    let res = run(
        "tests/data/valid_manifest.json",
        "tests/data/valid_proof.dat",
        Some("tests/data/timestamp.tsr"),
        Some("tests/data/registry.json"),
        Some("tests/data/verification.report.json"),
        Some(out),
        false,
        true
    );
    assert!(res.is_ok());
    assert!(std::path::Path::new(&format!("{}/_meta.json", out)).exists());
    assert!(std::path::Path::new(&format!("{}/README.txt", out)).exists());
}
```

---

## ðŸ“¦ Dependencies
- Add to `Cargo.toml` (if ZIP support is implemented now):
```toml
zip = "0.6"
chrono = "0.4"
sha3 = "0.10"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
anyhow = "1"
```

---

## ðŸ“˜ README Update

```markdown
### ðŸ“¦ Proof Package Export (v1.0)

Create a standardized, auditor-ready proof package as a folder or ZIP.

```bash
cap proof export \
  --manifest build/manifest.json \
  --proof build/zk_proof.dat \
  --timestamp build/timestamp.tsr \
  --registry build/registry.json \
  --report build/verification.report.json \
  --out build/cap-proof \
  --zip --force
```

Outputs:
- `build/cap-proof/` with fixed contents (see docs)
- Optional `build/cap-proof.zip`
- `_meta.json` contains SHA3 hashes for all files
```

---

## âœ… Acceptance Criteria

| Criterion | Description |
|------------|-------------|
| âœ” CLI | `cap proof export` creates `cap-proof/` or `cap-proof.zip` |
| âœ” Structure | Package contains required files + `_meta.json` |
| âœ” Hashes | SHA3-256 for each file stored in `_meta.json` |
| âœ” README | Human-readable instructions included |
| âœ” Tests | Folder export test passes (ZIP optional) |

---

## ðŸ”­ Future
- Switch `proof.dat` â†’ `proof.zkp` when real ZK backend lands.
- Add package signature (`cap-proof.sig`) for tamper-evident distribution.
- Register `.cap-proof.zip` MIME & file association for OS integration.
