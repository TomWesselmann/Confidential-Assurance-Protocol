//! CLI-Handler für Bundle-Kommandos
//!
//! Extrahiert aus main.rs für bessere Wartbarkeit.
//! Enthält: run_bundle_v2, run_verify_bundle

use super::output;
use crate::crypto;
use crate::verifier;
use std::error::Error;
use std::fs;
use std::io::Write;
use std::path::Path;

const VERSION: &str = "0.8.0";

// ============================================================================
// Helper-Funktionen für run_bundle_v2
// ============================================================================

/// Erstellt die _meta.json mit Hashes
fn create_bundle_meta(out: &str, manifest_hash: &str, proof_hash: &str) -> Result<(), Box<dyn Error>> {
    output::step(5, 7, "Creating _meta.json...");
    let meta = serde_json::json!({
        "bundle_version": "cap-proof.v2.0",
        "created_at": chrono::Utc::now().to_rfc3339(),
        "hashes": {
            "manifest_sha3": manifest_hash,
            "proof_sha3": proof_hash,
        },
        "backend": "mock",
    });
    fs::write(
        format!("{}/_meta.json", out),
        serde_json::to_string_pretty(&meta)?,
    )?;
    Ok(())
}

/// Erstellt die README.txt für Bundle v2
fn create_bundle_v2_readme(out: &str, manifest_hash: &str, proof_hash: &str) -> Result<(), Box<dyn Error>> {
    output::step(6, 7, "Creating README.txt...");
    let readme_content = format!(
        r#"CAP Proof Bundle v2.0
=====================

This directory contains a self-contained compliance proof package.

Contents:
---------
  manifest.json   - Compliance manifest with commitments and policy
  proof.capz      - CAPZ v2 proof container (binary format)
  _meta.json      - Bundle metadata with SHA3-256 integrity hashes
  README.txt      - This file

Optional files (if present):
  verifier.wasm   - WASM verifier module for offline verification
  executor.json   - WASM executor configuration

Verification:
-------------
To verify this bundle:

  1. Using cap-agent CLI:
     $ cap-agent verify-bundle --bundle . --out report.json

  2. Using WASM verifier (if included):
     The verifier will automatically detect and use verifier.wasm

  3. Manual hash verification:
     Compare hashes in _meta.json with actual file SHA3-256 hashes

Bundle Information:
-------------------
  Version:       cap-proof.v2.0
  Created:       {}
  Manifest Hash: {}
  Proof Hash:    {}

Integrity:
----------
All files in this bundle are hashed in _meta.json using SHA3-256.
Any tampering will be detected during verification.

Documentation:
--------------
For more information about CAP Proof Bundles, see:
  https://github.com/yourusername/cap-agent

Generated by cap-agent v{}
"#,
        chrono::Utc::now().to_rfc3339(),
        manifest_hash,
        proof_hash,
        VERSION
    );
    fs::write(format!("{}/README.txt", out), readme_content)?;
    Ok(())
}

/// Erstellt ein ZIP-Archiv des Bundle-Verzeichnisses
fn create_bundle_zip(out: &str) -> Result<(), Box<dyn Error>> {
    output::step(7, 7, "Creating ZIP archive...");
    let zip_path = format!("{}.zip", out);

    let zip_file = fs::File::create(&zip_path)?;
    let mut zip_writer = zip::ZipWriter::new(zip_file);
    let options = zip::write::FileOptions::<()>::default()
        .compression_method(zip::CompressionMethod::Deflated)
        .unix_permissions(0o755);

    let entries = fs::read_dir(out)?;
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            let file_data = fs::read(&path)?;
            zip_writer.start_file(file_name, options)?;
            zip_writer.write_all(&file_data)?;
        }
    }

    zip_writer.finish()?;
    output::indent(&format!("ZIP created: {}", zip_path));
    Ok(())
}

// ============================================================================
// Öffentliche CLI-Funktionen
// ============================================================================

/// Bundle v2 - Create self-contained proof package
pub fn run_bundle_v2(
    manifest: &str,
    proof: &str,
    verifier_wasm: Option<String>,
    out: &str,
    create_zip: bool,
    force: bool,
) -> Result<(), Box<dyn Error>> {
    output::packaging("Creating Proof Bundle v2...");

    // Check if output exists
    if Path::new(out).exists() && !force {
        return Err(format!("Output directory already exists: {}", out).into());
    }
    fs::create_dir_all(out)?;

    // Copy manifest
    output::step(1, 7, "Copying manifest...");
    let manifest_dest = format!("{}/manifest.json", out);
    fs::copy(manifest, &manifest_dest)?;

    // Copy proof
    output::step(2, 7, "Copying proof...");
    let proof_dest = format!("{}/proof.capz", out);
    fs::copy(proof, &proof_dest)?;

    // Note: WASM verifier support removed in minimal local agent
    if verifier_wasm.is_some() {
        output::warning("WASM verifier not supported in minimal agent, ignoring");
    }
    output::step(3, 7, "Using native verifier");
    output::step(4, 7, "Skipping WASM executor config");

    // Calculate hashes
    let manifest_bytes = fs::read(&manifest_dest)?;
    let proof_bytes = fs::read(&proof_dest)?;
    let manifest_hash = crypto::hex_lower_prefixed32(crypto::sha3_256(&manifest_bytes));
    let proof_hash = crypto::hex_lower_prefixed32(crypto::sha3_256(&proof_bytes));

    // Create metadata and README
    create_bundle_meta(out, &manifest_hash, &proof_hash)?;
    create_bundle_v2_readme(out, &manifest_hash, &proof_hash)?;

    // Optional ZIP
    if create_zip {
        create_bundle_zip(out)?;
    } else {
        output::step(7, 7, "Skipping ZIP creation");
    }

    output::section("");
    output::success("Bundle created successfully:");
    output::detail("Directory", out);
    output::detail("Manifest", &manifest_hash);
    output::detail("Proof", &proof_hash);

    Ok(())
}

/// Verify Bundle - Verify a proof package (native verifier, no WASM)
pub fn run_verify_bundle(bundle: &str, out: Option<String>) -> Result<(), Box<dyn Error>> {
    output::searching("Verifying Proof Bundle...");

    // Check bundle exists
    if !Path::new(bundle).exists() {
        return Err(format!("Bundle not found: {}", bundle).into());
    }

    output::step(1, 5, "Loading bundle...");

    // Load manifest and proof
    let manifest_path = format!("{}/manifest.json", bundle);
    let proof_path = format!("{}/proof.capz", bundle);

    if !Path::new(&manifest_path).exists() {
        return Err(format!("Manifest not found: {}", manifest_path).into());
    }
    if !Path::new(&proof_path).exists() {
        return Err(format!("Proof not found: {}", proof_path).into());
    }

    // Validate bundle integrity via _meta.json hashes
    output::step(2, 5, "Validating bundle integrity...");
    let meta_path = format!("{}/_meta.json", bundle);
    let manifest_bytes = fs::read(&manifest_path)?;
    let proof_bytes = fs::read(&proof_path)?;
    let manifest_hash = crypto::hex_lower_prefixed32(crypto::sha3_256(&manifest_bytes));
    let proof_hash = crypto::hex_lower_prefixed32(crypto::sha3_256(&proof_bytes));

    if Path::new(&meta_path).exists() {
        let meta_content = fs::read_to_string(&meta_path)?;
        let meta: serde_json::Value = serde_json::from_str(&meta_content)?;

        // Check manifest hash
        if let Some(expected_manifest_hash) = meta["hashes"]["manifest_sha3"].as_str() {
            if manifest_hash != expected_manifest_hash {
                return Err(format!(
                    "Bundle integrity check failed: Manifest hash mismatch\n  Expected: {}\n  Actual:   {}",
                    expected_manifest_hash, manifest_hash
                ).into());
            }
            output::indent("Manifest hash valid");
        }

        // Check proof hash
        if let Some(expected_proof_hash) = meta["hashes"]["proof_sha3"].as_str() {
            if proof_hash != expected_proof_hash {
                return Err(format!(
                    "Bundle integrity check failed: Proof hash mismatch\n  Expected: {}\n  Actual:   {}",
                    expected_proof_hash, proof_hash
                ).into());
            }
            output::indent("Proof hash valid");
        }
    } else {
        output::warning("No _meta.json found, skipping hash validation");
    }

    output::step(3, 5, "Using native verifier...");

    // Parse manifest as JSON Value (verifier expects serde_json::Value)
    let manifest_json: serde_json::Value = serde_json::from_slice(&manifest_bytes)?;

    // Create verification options
    output::step(4, 5, "Running verification...");
    let options = verifier::core::VerifyOptions {
        check_timestamp: false,
        check_registry: false,
    };

    // Extract statement and verify
    let stmt = verifier::core::extract_statement_from_manifest(&manifest_json)?;
    let report = verifier::core::verify(&manifest_json, &proof_bytes, &stmt, &options)?;

    output::step(5, 5, "Generating report...");
    output::section("");
    output::stats("Verification Report:");
    output::detail("Status", &report.status);
    output::detail("Manifest Hash", &manifest_hash);
    output::detail("Proof Hash", &proof_hash);
    output::detail(
        "Signature",
        if report.signature_valid { "valid" } else { "invalid" },
    );

    // Save report if requested
    if let Some(out_path) = out {
        let report_json = serde_json::to_string_pretty(&report)?;
        fs::write(&out_path, report_json)?;
        output::section("");
        output::saving(&format!("Report saved: {}", out_path));
    }

    if report.status != "ok" {
        return Err("Verification failed".into());
    }

    Ok(())
}
